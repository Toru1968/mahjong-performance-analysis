import pandas as pd
import sys
import re
from collections import Counter
import numpy as np
from typing import List

# --- ユーザー提供の mahjong ライブラリをインポート ---
try:
    from mahjong.shanten import Shanten
    from mahjong.tile import TilesConverter
except ImportError:
    print("エラー: 'mahjong' ライブラリが見つかりません。")
    print("コマンドプロンプトで 'pip install mahjong' を実行してインストールしてください。")
    sys.exit(1)

initial_players = ['A', 'B', 'C', 'D']
PLAYERS = ['A','B','C','D']
parent_idx = 0
prev_kyoku = None

TILES_MAP = {
    **{f'{i}m': 10+i for i in range(1, 10)},
    **{f'{i}p': 20+i for i in range(1, 10)},
    **{f'{i}s': 30+i for i in range(1, 10)},
    **{f'{i}z': 40+i for i in range(1, 8)}, # 1z-7z
    '0m': 51, # 赤ドラ5m
    '0p': 52, # 赤ドラ5p
    '0s': 53  # 赤ドラ5s
}
INV_TILES_MAP = {v: k for k, v in TILES_MAP.items()}

def to_str(tile_int):
    return INV_TILES_MAP.get(tile_int, '?')

def to_int(tile_str):
    return TILES_MAP.get(tile_str, 0)

def format_hand(hand_ints, sort=True):
    hand_list =[]
    if sort:
        hand_ints.sort()
    hand_list= ([to_str(t) for t in hand_ints])
    return hand_list

def parse_tile_list_string(tile_list_str: str) -> List[str]:
    if not isinstance(tile_list_str, str) or not tile_list_str: return []
    tiles, i = [], 0
    while i < len(tile_list_str):
        if i + 1 < len(tile_list_str):
            num_char, suit_char = tile_list_str[i], tile_list_str[i+1]
            if (num_char.isdigit() or num_char == '0') and suit_char in ['m', 'p', 's', 'z']:
                tiles.append(num_char + suit_char); i += 2
            else: i += 1
        else: i += 1
    return tiles

def convert_tile_counts_34(tiles):
    red_tile_map = {'0m': '5m', '0p': '5p', '0s': '5s'}
    normalized_tiles = [red_tile_map.get(tile, tile) for tile in tiles]
    tile_order = [
        '1m', '2m', '3m', '4m', '5m', '6m', '7m', '8m', '9m',
        '1p', '2p', '3p', '4p', '5p', '6p', '7p', '8p', '9p',
        '1s', '2s', '3s', '4s', '5s', '6s', '7s', '8s', '9s',
        '1z', '2z', '3z', '4z', '5z', '6z', '7z'
    ]
    count_map = Counter(normalized_tiles)
    tile_counts_34 = [count_map.get(tile, 0) for tile in tile_order]
    return tile_counts_34

def get_tile_sort_key(tile_str: str) -> tuple:
    if not isinstance(tile_str, str) or len(tile_str) < 2: return (99, 99)
    suit_order = {'m': 0, 'p': 1, 's': 2, 'z': 3}
    num_char, suit_char = tile_str[0], tile_str[1]
    tile_num = 5 if num_char == '0' else int(num_char)
    return (suit_order.get(suit_char, 99), tile_num)

def hand_strings_to_34_array(hand_strings: list[str]) -> np.ndarray:
    man, pin, sou, honors = [], [], [], []
    for tile in hand_strings:
        if not isinstance(tile, str) or len(tile) != 2: continue
        num, suit = tile[0], tile[1]
        if num == '0': num = '5'
        if suit == 'm': man.append(num)
        elif suit == 'p': pin.append(num)
        elif suit == 's': sou.append(num)
        elif suit == 'z': honors.append(num)
    return TilesConverter.string_to_34_array(man="".join(man), pin="".join(pin), sou="".join(sou), honors="".join(honors))

def calculate_shanten(hand_strings: list[str], open_melds: list = None) -> int:
    try:
        all_tiles = list(hand_strings)
        if open_melds:
            for meld in open_melds:
                all_tiles.extend(meld['tiles'])
        valid_counts = [1, 2, 4, 5, 7, 8, 10, 11, 13, 14]
        if len(all_tiles) not in valid_counts: return 8
        tiles_34 = hand_strings_to_34_array(all_tiles)
        return Shanten().calculate_shanten(tiles_34)
    except Exception: return 8

def calculate_shanten_for_14_tiles(tiles_14):
    best_shanten = float('inf')
    best_discard = None

    for i in range(len(tiles_14)):
        temp_hand = tiles_14[:i] + tiles_14[i+1:]  # 13枚にする
        shanten = calculate_shanten(temp_hand)

        if shanten < best_shanten:
            best_shanten = shanten
            best_discard = tiles_14[i]  # この牌を捨てると最も良い

    return best_shanten,best_discard

# ==============================================================================
# 牌山生成ロジック
# ==============================================================================
def generate_mahjong_wall():
    """
    オンライン麻雀ゲームで一般的に採用されている、シード値を使わない
    標準的な牌山生成ロジック (全136枚) を生成します。
    """
    # 萬子 (マンズ): 1m - 9m 各4枚 (通常の5mも含む)
    manzu = [10 + i for i in range(1, 10)] * 4
    # 筒子 (ピンズ): 1p - 9p 各4枚 (通常の5pも含む)
    pinzu = [20 + i for i in range(1, 10)] * 4
    # 索子 (ソーズ): 1s - 9s 各4枚 (通常の5sも含む)
    souzu = [30 + i for i in range(1, 10)] * 4
    # 字牌 (ツーパイ): 東西南北白発中 各4枚
    zihai = [40 + i for i in range(1, 8)] * 4 # 7種類

    all_tiles = manzu + pinzu + souzu + zihai

    red_dora_ints = [51, 52, 53] # 0m, 0p, 0s の内部表現
    normal_five_ints = [15, 25, 35] # 5m, 5p, 5s の内部表現

    for red_dora_int, normal_five_int in zip(red_dora_ints, normal_five_ints):
        try:
            idx = all_tiles.index(normal_five_int)
            all_tiles[idx] = red_dora_int
        except ValueError:
            print(f"警告: 通常の牌 {to_str(normal_five_int)} が牌山に見つかりませんでした。")
            return None # 異常終了

    if len(all_tiles) != 136:
         print(f"エラー: 牌山生成数が不正です ({len(all_tiles)}枚)")
         return None

    random.shuffle(all_tiles)

    return all_tiles

# --- メイン処理 ---
def analyze_report(file_path: str, turns_to_check: int = 6):
    """CSV ファイルを読み込み、向聴数の進捗を分析する"""
    df = pd.read_csv(file_path)

    # 局ごとにデータをグループ化
    grouped_by_game = df.groupby('index')

    total_improvements = 0
    total_draws_checked = 0
    total_zero_shanten_turns = 0 # 聴牌した回数をカウント
    tenpai_turn_counts = defaultdict(int) # 聴牌した巡目ごとのカウント

    print(f"--- 序盤{turns_to_check}巡の向聴数 進捗分析 (高精度版) ---")

    for game_index, game_df in grouped_by_game:
        print(f"[{game_index:3d}局目]")
        for row_index, row in game_df.iterrows():
            try:
                seat = row['seat']
                hand_str = parse_tile_list_string(row['hand'])
                draws_str = parse_tile_list_string(row['draws'])
            except (AttributeError, KeyError):
                print(f"警告: {row_index + 1}行目のデータ形式が正しくありません。スキップします。")
                continue

            shanten_history = []
            # 副露がないため、手牌のみで計算
            current_shanten = calculate_shanten(hand_str)
            shanten_history.append(current_shanten)

            improvements_in_game = 0
            hand_copy = list(hand_str)
            tenpai_turn = -1 # 聴牌した巡目を記録

            # 最初の配牌(0 巡目)は手牌のみでシャンテン数計算済み
            # その後のツモ牌を 1 枚ずつ処理
            for i in range(min(len(draws_str), turns_to_check)):
                # ツモ牌を手牌に加える
                hand_copy.append(draws_str[i])
                hand_copy.sort() # ソートは必須ではないが、確認しやすい

                # 14 枚になった手牌で最もシャンテン数が良くなる打牌を探す
                best_shanten_after_discard, discard = calculate_shanten_for_14_tiles(hand_copy)

                # 最適な打牌後の手牌（13 枚）の状態を次のツモに引き継ぐ
                # ※ここではシャンテン数計算のために一時的に 14 枚にしていたが、
                #   実際に次のツモに進む手牌は 13 枚に戻す必要がある。
                #   最もシャンテン数が良くなる牌を捨てるというロジックを採用。
                #   これは calculate_shanten_for_14_tiles で計算されている discard を使用する
                if discard is not None and discard in hand_copy:
                     hand_copy.remove(discard)
                else:
                     # 万が一 discard が見つからない場合は、ツモった牌をそのまま切ったと見なす（簡易処理）
                     if draws_str[i] in hand_copy:
                         hand_copy.remove(draws_str[i])


                # シャンテン数が進んだか判定
                if best_shanten_after_discard < current_shanten:
                    improvements_in_game += 1

                current_shanten = best_shanten_after_discard
                shanten_history.append(current_shanten)

                # 初めて向聴数が 0 になったかチェックし、巡目を記録
                if current_shanten == 0 and tenpai_turn == -1:
                    tenpai_turn = i + 1 # i は 0 から始まるため、巡目は i + 1
                    tenpai_turn_counts[tenpai_turn] += 1 # 聴牌巡目をカウント

            total_improvements += improvements_in_game
            # 実際にチェックしたツモの回数を加算 (turns_to_check または draws_str の長さの短い方)
            total_draws_checked += min(len(draws_str), turns_to_check)


            shanten_str = ' -> '.join(map(str, shanten_history))
            tenpai_info = f", 聴牌巡目: {tenpai_turn}巡" if tenpai_turn != -1 else ""
            print(f"  [{seat}] 向聴数推移: {shanten_str} ({improvements_in_game}/{min(len(draws_str), turns_to_check)}回進捗){tenpai_info}")
            if tenpai_turn != -1:
                total_zero_shanten_turns += 1


    print("\n--- 分析結果 ---")
    if total_draws_checked > 0:
        average_improvement_rate = (total_improvements / total_draws_checked) * 100
        print(f"全{len(grouped_by_game)}局の分析が完了しました。")
        print(f"序盤{turns_to_check}巡におけるツモでの合計進捗回数: {total_improvements}回")
        print(f"序盤{turns_to_check}巡における合計ツモ回数: {total_draws_checked}回")
        print(f"序盤{turns_to_check}巡におけるツモでの平均進捗率: {average_improvement_rate:.2f}%")
        print(f"序盤{turns_to_check}巡以内に聴牌した回数: {total_zero_shanten_turns}回")

        # 聴牌巡目の分布を表示
        print("\n--- 聴牌巡目分布 (6 巡以内) ---")
        if tenpai_turn_counts:
            # 巡目順にソートして表示
            for turn in sorted(tenpai_turn_counts.keys()):
                count = tenpai_turn_counts[turn]
                print(f"  {turn}巡目: {count}回")
        else:
            print("  6 巡以内に聴牌したケースはありませんでした。")

    else:
        print("分析可能なデータがありませんでした。")

if __name__ == "__main__":
    analyze_report("analyzed_report.csv")